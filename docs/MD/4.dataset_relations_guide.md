# Guide Détaillé : Relations et Jointures entre Datasets

## 🎯 Objectif
Comprendre comment lier les données de **vols** avec les **conditions météorologiques** en utilisant le dataset **wban_airport_timezone.csv** comme pont.

---

## 📊 Architecture des Relations

```
┌─────────────────────────────────────────────────────────────────┐
│                    FLUX DE JOINTURE                              │
└─────────────────────────────────────────────────────────────────┘

    [Flights_samples.csv]
           │
           │ ORIGIN_AIRPORT_ID = 12478 (Ex: JFK)
           │ DEST_AIRPORT_ID = 14107 (Ex: ORD)
           │ FL_DATE = "2024-01-15"
           │ CRS_DEP_TIME = 845 (08h45)
           ↓
    ┌──────────────────────────────┐
    │  wban_airport_timezone.csv   │  ← TABLE DE CORRESPONDANCE
    │  AirportID → WBAN → TimeZone │
    └──────────────────────────────┘
           │
           │ AirportID = 12478 → WBAN = 94789
           │ TimeZone = -5 (UTC-5, EST)
           ↓
    [Weather_samples.csv]
           │
           │ WBAN = 94789
           │ Date = 20240115
           │ Time = 845
           │ → Conditions météo de JFK à 08h45
```

---

## 🔍 Étape 1 : Comprendre le rôle du WBAN

### Qu'est-ce que le WBAN ?
**WBAN** = **W**eather **B**ureau **A**rmy **N**avy

- Code unique identifiant une **station météorologique**
- Chaque aéroport est associé à une (ou plusieurs) station(s) WBAN proche(s)
- C'est la **clé de jointure** entre aéroports et données météo

### Exemple concret

```
┌─────────────────────────────────────────────────────────────┐
│         wban_airport_timezone.csv                            │
├───────────────┬─────────────┬──────────────┬────────────────┤
│  AirportID    │    WBAN     │   TimeZone   │  Airport Name  │
├───────────────┼─────────────┼──────────────┼────────────────┤
│  12478        │   94789     │      -5      │  JFK (New York)│
│  14107        │   94846     │      -6      │  ORD (Chicago) │
│  11292        │   03927     │      -8      │  LAX (LA)      │
│  10397        │   13874     │      -5      │  ATL (Atlanta) │
└───────────────┴─────────────┴──────────────┴────────────────┘
```

**Interprétation :**
- L'aéroport **JFK (ID 12478)** utilise la station météo **WBAN 94789**
- Le fuseau horaire est **UTC-5** (Eastern Time)

---

## 🔗 Étape 2 : Jointure Aéroports ↔ Stations Météo

### Scénario : Un vol de JFK à Chicago

**Données du vol :**
```
┌─────────────────────────────────────────────────────────────────┐
│                   Flights_samples.csv                            │
├──────────┬─────────────┬────────────────┬──────────────────────┤
│ FL_DATE  │ CRS_DEP_TIME│ORIGIN_AIRPORT_ID│ DEST_AIRPORT_ID    │
├──────────┼─────────────┼────────────────┼──────────────────────┤
│2024-01-15│    845      │     12478      │       14107          │
│          │  (08h45)    │     (JFK)      │       (ORD)          │
└──────────┴─────────────┴────────────────┴──────────────────────┘
```

### Jointure #1 : Récupérer le WBAN de l'aéroport d'origine

```sql
SELECT 
    f.FL_DATE,
    f.CRS_DEP_TIME,
    f.ORIGIN_AIRPORT_ID,
    w.WBAN as ORIGIN_WBAN,
    w.TimeZone as ORIGIN_TIMEZONE
FROM Flights_samples f
LEFT JOIN wban_airport_timezone w
    ON f.ORIGIN_AIRPORT_ID = w.AirportID
```

**Résultat :**
```
┌──────────┬─────────────┬─────────────────┬─────────────┬────────────────┐
│ FL_DATE  │CRS_DEP_TIME │ORIGIN_AIRPORT_ID│ORIGIN_WBAN  │ORIGIN_TIMEZONE │
├──────────┼─────────────┼─────────────────┼─────────────┼────────────────┤
│2024-01-15│    845      │     12478       │   94789     │      -5        │
└──────────┴─────────────┴─────────────────┴─────────────┴────────────────┘
```

✅ **On a maintenant le code WBAN de la station météo de JFK !**

---

## 🌦️ Étape 3 : Jointure avec les Données Météo

### Données météo disponibles

```
┌────────────────────────────────────────────────────────────────────┐
│                    Weather_samples.csv                              │
├──────┬──────────┬──────┬───────────────┬──────────┬───────────────┤
│ WBAN │   Date   │ Time │DryBulbCelsius │Visibility│  SkyCondition │
├──────┼──────────┼──────┼───────────────┼──────────┼───────────────┤
│94789 │20240115  │ 800  │      -2.0     │   10.0   │   CLR         │
│94789 │20240115  │ 845  │      -1.5     │    9.5   │   SCT         │
│94789 │20240115  │ 900  │      -1.0     │    9.8   │   SCT         │
│94846 │20240115  │ 830  │      -5.0     │    8.0   │   OVC         │
└──────┴──────────┴──────┴───────────────┴──────────┴───────────────┘
```

### Jointure #2 : Associer la météo au vol

```sql
SELECT 
    f.FL_DATE,
    f.CRS_DEP_TIME,
    f.ORIGIN_AIRPORT_ID,
    w.DryBulbCelsius,
    w.Visibility,
    w.SkyCondition,
    w.WindSpeed,
    w.RelativeHumidity
FROM Flights_samples f
LEFT JOIN wban_airport_timezone wban
    ON f.ORIGIN_AIRPORT_ID = wban.AirportID
LEFT JOIN Weather_samples w
    ON wban.WBAN = w.WBAN
    AND CAST(f.FL_DATE AS INT) = w.Date
    AND f.CRS_DEP_TIME = w.Time
```

**Résultat final :**
```
┌──────────┬─────────────┬─────────────┬──────────────┬───────────┬─────────────┐
│ FL_DATE  │CRS_DEP_TIME │ORIGIN_AIRPORT│Temperature  │Visibility │SkyCondition │
├──────────┼─────────────┼─────────────┼──────────────┼───────────┼─────────────┤
│2024-01-15│    845      │   12478     │    -1.5°C    │   9.5 mi  │    SCT      │
└──────────┴─────────────┴─────────────┴──────────────┴───────────┴─────────────┘
```

✅ **On a les conditions météo à JFK au moment du départ !**

---

## ⚠️ Défis de la Jointure Temporelle

### Problème 1 : Format des dates différent

```
Flights:  FL_DATE = "2024-01-15"  (String au format YYYY-MM-DD)
Weather:  Date = 20240115          (Integer au format YYYYMMDD)
```

**Solution Scala :**
```scala
// Convertir FL_DATE en format Integer
val flightsWithDate = flights.withColumn(
  "DATE_INT",
  regexp_replace(col("FL_DATE"), "-", "").cast(IntegerType)
)
```

### Problème 2 : Format des heures différent

```
Flights:  CRS_DEP_TIME = 845    (Integer : 8h45)
Weather:  Time = "0845"          (String : 08h45)
```

**Solution Scala :**
```scala
// Normaliser les heures au format 4 chiffres
val flightsWithTime = flights.withColumn(
  "TIME_NORMALIZED",
  lpad(col("CRS_DEP_TIME").cast(StringType), 4, "0")
)
```

### Problème 3 : Observations météo manquantes

Les observations météo sont **horaires**, mais les vols peuvent partir à **n'importe quelle minute**.

**Exemple :**
- Vol départ prévu : **08h37**
- Observations météo : 08h00, 08h30, 09h00
- ❌ Pas d'observation exacte à 08h37

**Solutions possibles :**

#### Option A : Observation la plus proche (avant le départ)
```scala
// Prendre la dernière observation AVANT le départ
val weatherBeforeDeparture = weather.alias("w")
  .join(
    flights.alias("f"),
    col("w.WBAN") === col("f.ORIGIN_WBAN") &&
    col("w.Date") === col("f.DATE_INT") &&
    col("w.Time") <= col("f.TIME_NORMALIZED")
  )
  .groupBy("f.flight_id")
  .agg(max("w.Time").as("closest_time"))
```

#### Option B : Fenêtre temporelle (±30 minutes)
```scala
// Prendre l'observation dans une fenêtre de 30 min
val windowedJoin = flights.join(
  weather,
  col("WBAN") === col("ORIGIN_WBAN") &&
  col("Date") === col("DATE_INT") &&
  abs(col("Time") - col("TIME_NORMALIZED")) <= 30
)
```

#### Option C : Interpolation linéaire
```scala
// Moyenne pondérée entre observation avant et après
// Plus complexe mais plus précis
```

---

## 💻 Code Scala Complet : Jointure pas à pas

### Version 1 : Jointure Simple (exacte)

```scala
import org.apache.spark.sql.SparkSession
import org.apache.spark.sql.functions._
import org.apache.spark.sql.types._

object FlightWeatherJoin {
  def main(args: Array[String]): Unit = {
    val spark = SparkSession.builder()
      .appName("Flight Weather Join")
      .master("local[*]")
      .getOrCreate()

    import spark.implicits._

    // 1. Charger les datasets
    val flights = spark.read
      .option("header", "true")
      .option("inferSchema", "true")
      .csv("Flights_samples.csv")

    val weather = spark.read
      .option("header", "true")
      .option("inferSchema", "true")
      .csv("Weather_samples.csv")

    val wbanMapping = spark.read
      .option("header", "true")
      .option("inferSchema", "true")
      .csv("wban_airport_timezone.csv")

    // 2. Préparer les données de vols
    val flightsPrepared = flights
      .filter(col("CANCELLED") === 0 && col("DIVERTED") === 0) // Filtrer vols annulés
      .withColumn("DATE_INT", 
        regexp_replace(col("FL_DATE"), "-", "").cast(IntegerType))
      .withColumn("TIME_NORMALIZED",
        lpad(col("CRS_DEP_TIME").cast(StringType), 4, "0"))

    // 3. Jointure #1 : Vols → WBAN (Origine)
    val flightsWithOriginWBAN = flightsPrepared
      .join(
        wbanMapping.select(
          col("AirportID").as("ORIGIN_AIRPORT_ID"),
          col("WBAN").as("ORIGIN_WBAN"),
          col("TimeZone").as("ORIGIN_TIMEZONE")
        ),
        Seq("ORIGIN_AIRPORT_ID"),
        "left"
      )

    // 4. Jointure #2 : Vols → Météo Origine
    val flightsWithOriginWeather = flightsWithOriginWBAN
      .join(
        weather.select(
          col("WBAN").as("ORIGIN_WBAN"),
          col("Date").as("WEATHER_DATE"),
          col("Time").as("WEATHER_TIME"),
          col("DryBulbCelsius").as("ORIGIN_TEMP"),
          col("RelativeHumidity").as("ORIGIN_HUMIDITY"),
          col("WindSpeed").as("ORIGIN_WIND"),
          col("Visibility").as("ORIGIN_VISIBILITY"),
          col("SkyCondition").as("ORIGIN_SKY"),
          col("HourlyPrecip").as("ORIGIN_PRECIP")
        ),
        col("ORIGIN_WBAN") === col("ORIGIN_WBAN") &&
        col("DATE_INT") === col("WEATHER_DATE") &&
        col("TIME_NORMALIZED") === col("WEATHER_TIME"),
        "left"
      )

    // 5. Optionnel : Jointure pour aéroport de destination
    val flightsWithDestWBAN = flightsWithOriginWeather
      .join(
        wbanMapping.select(
          col("AirportID").as("DEST_AIRPORT_ID"),
          col("WBAN").as("DEST_WBAN")
        ),
        Seq("DEST_AIRPORT_ID"),
        "left"
      )

    // 6. Afficher le résultat
    flightsWithDestWBAN.select(
      "FL_DATE",
      "CRS_DEP_TIME",
      "ORIGIN_AIRPORT_ID",
      "DEST_AIRPORT_ID",
      "ORIGIN_WBAN",
      "ORIGIN_TEMP",
      "ORIGIN_VISIBILITY",
      "ORIGIN_SKY",
      "ARR_DELAY_NEW"
    ).show(10)

    spark.stop()
  }
}
```

---

### Version 2 : Jointure avec Fenêtre Temporelle

```scala
// Pour gérer les observations météo manquantes
object FlightWeatherJoinWindowed {
  
  def joinWithTimeWindow(
    flights: DataFrame,
    weather: DataFrame,
    wbanMapping: DataFrame,
    windowMinutes: Int = 30
  ): DataFrame = {
    
    // Préparer les données
    val flightsPrepared = flights
      .withColumn("DATE_INT", 
        regexp_replace(col("FL_DATE"), "-", "").cast(IntegerType))
      .withColumn("DEP_TIME_MINUTES", 
        (col("CRS_DEP_TIME") / 100).cast(IntegerType) * 60 + 
        (col("CRS_DEP_TIME") % 100).cast(IntegerType)
      )
    
    val weatherPrepared = weather
      .withColumn("WEATHER_TIME_MINUTES",
        (col("Time").cast(IntegerType) / 100) * 60 +
        (col("Time").cast(IntegerType) % 100)
      )
    
    // Jointure avec WBAN
    val flightsWithWBAN = flightsPrepared
      .join(
        wbanMapping.select(
          col("AirportID").as("ORIGIN_AIRPORT_ID"),
          col("WBAN").as("ORIGIN_WBAN")
        ),
        Seq("ORIGIN_AIRPORT_ID"),
        "left"
      )
    
    // Jointure avec fenêtre temporelle
    val joined = flightsWithWBAN
      .join(
        weatherPrepared,
        col("ORIGIN_WBAN") === col("WBAN") &&
        col("DATE_INT") === col("Date") &&
        abs(col("DEP_TIME_MINUTES") - col("WEATHER_TIME_MINUTES")) <= windowMinutes,
        "left"
      )
      // Prendre l'observation la plus proche
      .withColumn("time_diff", 
        abs(col("DEP_TIME_MINUTES") - col("WEATHER_TIME_MINUTES")))
      .withColumn("rn",
        row_number().over(
          Window.partitionBy("FL_DATE", "OP_CARRIER_FL_NUM", "ORIGIN_AIRPORT_ID")
            .orderBy(col("time_diff"))
        )
      )
      .filter(col("rn") === 1)
      .drop("rn", "time_diff")
    
    joined
  }
}
```

---

## 📊 Exemple Complet avec Résultat

### Données d'entrée

**Flight :**
```
FL_DATE: 2024-01-15
CRS_DEP_TIME: 845
ORIGIN_AIRPORT_ID: 12478 (JFK)
DEST_AIRPORT_ID: 14107 (ORD)
ARR_DELAY_NEW: 23.0
```

**WBAN Mapping :**
```
AirportID: 12478 → WBAN: 94789, TimeZone: -5
```

**Weather (station 94789, 2024-01-15) :**
```
Time: 0845
DryBulbCelsius: -1.5
RelativeHumidity: 75
WindSpeed: 15
Visibility: 9.5
SkyCondition: SCT
HourlyPrecip: 0.0
```

### Données de sortie (après jointure)

```
┌──────────┬─────────────┬──────────────┬──────────┬──────────┬──────────┬────────┬──────────────┐
│ FL_DATE  │CRS_DEP_TIME │ORIGIN_AIRPORT│ORIGIN_TEMP│VISIBILITY│WIND_SPEED│HUMIDITY│ARR_DELAY_NEW │
├──────────┼─────────────┼──────────────┼──────────┼──────────┼──────────┼────────┼──────────────┤
│2024-01-15│    845      │    12478     │  -1.5°C  │  9.5 mi  │  15 kts  │  75%   │    23.0      │
└──────────┴─────────────┴──────────────┴──────────┴──────────┴──────────┴────────┴──────────────┘
```

✅ **Dataset prêt pour le Machine Learning !**

---

## 🎯 Résumé de la Stratégie

1. **WBAN = Pont central** entre aéroports et météo
2. **Deux jointures successives** : Flights → WBAN → Weather
3. **Normalisation temporelle** : Convertir dates et heures au même format
4. **Gestion des manques** : Fenêtre temporelle ou observation la plus proche
5. **Doubler la jointure** pour avoir la météo à l'origine ET à la destination

---

## 🚀 Prochaines Étapes

Maintenant que vous comprenez la jointure, nous pouvons :

1. ✅ Implémenter le **preprocessing complet**
2. ✅ Créer le **feature engineering** (extraction de features temporelles)
3. ✅ Construire le **pipeline Spark ML**
4. ✅ Entraîner le **modèle de prédiction**

Que voulez-vous implémenter en premier ?